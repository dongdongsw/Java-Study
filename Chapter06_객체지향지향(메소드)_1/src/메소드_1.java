/*
 * 	1. 객체지향 프로그램
 * 		ㄴ 클래스
 * 			ㄴ 1) 클래스 구성요소
 * 				ㄴ 변수
 * 					ㄴ 인스턴트 변수 :메모리에 저장할 때 따로 저장
 * 									ㄴ 저장시기 => new
 * 										ㄴ heap => 프로그그래머가 관리
 * 					ㄴ 정적 변수 : static => 메모리 공간을 한개 사용
 * 								ㄴ 공유하는 변수
 * 									ㄴ MethodArea
 * 					ㄴ 지역 변수 : 메소드가 종료되면 사라지는 변수
 * 								ㄴ Stack => {} 메모리 자체가 관리를 함
 * 				ㄴ 메소드
 * 					ㄴ 목적	
 * 						ㄴ 반복기능 제거
 * 							ㄴ 데이터베이스, 네트워크 (서버 = 클라이언트)
 * 								ㄴ 모든 기능		ㄴ 보내기 / 받기
 * 								ㄴ 오라클 연결
 * 								ㄴ 기능 처리
 * 								ㄴ 오라클 닫기 ( 열고 닫기를 명확히 하기 )
 * 									ㄴ 유지보수 : 기능(기능을 추가할 때 메소드 사용함)
 * 										ㄴ 메소드는 프로그램의 80%
 * 							ㄴ 소스가 간결해 진다
 * 							ㄴ 재사용 (다른 클래스와 연결)
 * 								ㄴ 오버로딩 / 오버라이딩 => 메소드
 * 							ㄴ 단락을 나누는 과정
 * 								ㄴ 코드 관리가 쉽게 (기능별 분리)
 * 								ㄴ 가독성
 * 									ㄴ 1. 가독성
 * 									ㄴ 2. 최적화
 * 									ㄴ 3. AWS => scp / async
 * 									ㄴ 4. 공통으로 사용되는 기능 => 공통 모듈
 * 
 * 				ㄴ 생성자 : 변수에 대한 초기화
 * 					ㄴ 프로그램에서 가장 먼저 호출 
 * 					ㄴ 시작과 동시에 구현
 * 					ㄴ 서버 / 데이터베이스 / 화면 UI
 * 					ㄴ 자동 로그인 / 
 * 					ㄴ 메소드의 일종
 * 					ㄴ . => new 생성자()
 * 				함수 / 메소드
 * 				 ㄴ 기능 처리
 * 				 ㄴ 독립적 : 함수 : c++ , 파이썬
 * 				 ㄴ 메소드 => 클래스 영역 => 클래스 종속
 * 							자바 , c#
 * 			 라이브러리(완제품) / 프레임 워크(레고 같은 느낌)
 * 			-----------------------------------------
 * 			1. 변수 / 2. 메소드
 * 			
 * 		2) 메소드
 * 			ㄴ 형식)
 * 				ㄴ [접근지정어][제어어] 리턴형 메소드명(매개변수 목록){
 * 						---- 명령문
 * 						----
 * 						return 값;
 * 
 * 					}
 * 				ㄴ 접근 지정어 ( public, private, protected, default)
 * 					ㄴ 접근 지정어를 사용 안하면 default를 기본을 사용함 = > 같은 폴더 안에서  접근 가능
 * 					ㄴ public : 외부 클래스에서 사용할 수 있게 함 ( 다른 패키지에서 사용할 수 있게 한다는 의미)
 * 					ㄴ private : 외부에서 사용할 수 없게 함 ( 다른 패키지에서 사용할 수 없게 함)
 * 					ㄴ protected : 같은 패키지 혹은 자식들이 사용할 수 있게 함
 * 
 * 				ㄴ 제어어 ( static, final, abstract)
 * 					ㄴ static => 컴파일시에 자동 저장 => static이 없으면 저장이 안된다( 5% 정도만 사용함 나머지느 인스턴스 95% )
 * 					ㄴ final => 값을 변하지 않게 하는 것
 * 					ㄴ abstarct =>  공통된 필드와 메서드를 선언해서 다른 곳에서 사용이 가능하게 하는 것(객체를 생성할 수 없음)
 * 				
 * 				ㄴ 데이터가 여러개 : 배열 / 클래스
 * 								------------
 * 								한개의 이름
 * 				ㄴ 자바는 리턴형을 반드시 1개만 사용이 가능
 * 				ㄴ 메소드 자체 처리
 * 					ㄴ 출력 / 추가 / 삭제 / 수정 => void
 * 					ㄴ 메서드 명 
 * 						ㄴ 식별자 
 * 							ㄴ 알파벳 아용, 한글 => 알파벳 권장
 * 							ㄴ 대소문자 구분
 * 							ㄴ 약속 : 소문자로 시작
 * 							ㄴ 숫자 사용( 앞에 사용 금지 )
 * 							ㄴ 키워드 사용 금지
 * 							ㄴ 공백없이 사용
 * 							ㄴ 가급적이면 의미 부여
 * 							  ------------------ 글자수 제한은 없다
 * 			ㄴ 매개변수) : 사용자 요청 데이터
 * 				ㄴ 가공 => 결과 값 도출
 * 				ㄴ 없는 경우 / 여러개 / 한개 ...
 * 				ㄴ 검색 요청
 * 					ㄴ 검색어 1개
 * 				ㄴ 로그인
 * 					ㄴ id / password
 * 				ㄴ 회원가입
 * 					ㄴ id, pwd, name, sex, birthday ...
 * 					 ----------------------------------
 * 						class
 * 
 * 				ㄴ 정렬
 * 					ㄴ 배열
 * 			---------------------------3개이상이면 배열 / 클래스
 * 			ㄴ 동작)
 * 				ㄴ 호출 => 매개변수 => 처리 => 결과값 돌려준다
 * 			ㄴ 기본) : 재사용 / 다른 클래스 통신
 * 				ㄴ 반드시 한개의 기능만 수행
 * 				ㄴ 최대한 세부적으로 분리 
 * 		
 * 			ㄴ static void aaa(int a) {}
 * 				ㄴ 같은 클래스에서 호출
 * 					aaa(10) => 실제 값 주입
 * 				ㄴ 다른 클래스에서 호출
 * 					ㄴ 클래스명.aaa(20)
 * 				ㄴ 메소드를 호출할 경우
 * 					ㄴ 처음부터 끝까지 수행 => 호출한 위치 원상 복귀
 * 				ㄴ 메소드 종료
 * 					ㄴ return 이 있는 곳에서 종료
 * 				ㄴ 특별한 경우가 아니면 void에는 return 생략
 * 					ㄴ return이 없는 건 아님 보이지 않는 백그라운드에 존재함
 * 
 * 
 *	<절차적 언어는 재사용이 불가능>
 *		ㄴ 소스 수정이 어렵다			
 *		ㄴ 개선 사항
 * 			ㄴ 재사용이 가능 / 게임을 다시 수행
 * 			ㄴ 소스를 관련 내용을 모아서 관리 ==> 수정
 * 			ㄴ 구조적인 프로그램 (메소드)
 * 			-----------------------
 * 			매개변수 / 리턴형 너무 많다
 * 			---------------------
 * 				전연 변수 도입
 * 			ㄴ 객체 지향 프로그램
 * 
 * <숫자 야구 게임>
 * 난수 발생 : 임의의 수 3개 추출
 * ------------------------
 * 사용자 입력
 * 비교
 * 힌트
 * 종료 여부
 * -------------배소드 5개
 * => 전체 조립
 * -------------1개 process()
 * 
 * 1. 매개변수 전송
 * 2. 호출 위치
 * 3. 다시 게임 => 재귀 호출
 * 
 */

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.util.Scanner;

public class 메소드_1 {
	
	static int[] rand() {
		
		//재사용이 어렵다
		int[] com = new int[3];
		for(int i = 0; i< com.length; i++) {
			com[i] = (int)(Math.random()*9)+1;
			for(int j = 0; j < i; j++) {
				if(com[j] == com[i]) {
					i--;
					break;
				}
			
			}
		}
		return com;
	}
	
// 절차적 언어 ==> 구조적 언어 => 객체 지향(oop) => 횡단 지향(AOP)
	public static void main(String[] args){
		
		//분리를 시키자----------------------------
		int[] com = new int[3];
		
		for(int i = 0; i< com.length; i++) {
			com[i] = (int)(Math.random()*9)+1;
			for(int j = 0; j < i; j++) {
				if(com[j] == com[i]) {
					i--;
					break;
				}
					
			}
		}
		//--------------------------------------
		
		
		//사용자 입력 받기
		int[] user = new int[3];
		Scanner scan = new Scanner(System.in);
		while(true) {
			//사용자 입력
			System.out.println("세자리 정수 입력 :");
			int input = scan.nextInt();
			
			//오류 처리 => 입력이 잘못된 경우
			// 1. 세자리 정수가 아닌 경우
			// 2. 중복된 수 입력이 된경우
			// 3. 0을 입력하는 경우
			if(100 > input && 999 < input) {
				System.out.println("잘못된 입력입니다");
				continue;
			}
			user[0] = input/100;
			user[1] = (input%100)/10;
			user[2] = input%100;
			
			if(user[0] == user[1] || user[1] == user[2] ||user[0] == user[2]) {
				System.out.println("중복된 수는 사용할 수 없다");
				continue;
			}
			
			if(user[0] == 0 || user[1] == 0 || user[2] == 0) {
				System.out.println("0은 사용할 수 없다");
				continue;
				
			}
			
			//비교 => 힌트 => s: 같은 위치의 같은 값 b : 다른 자리에 같은 값
			int s = 0, b = 0;
			for(int i=0; i<3; i++) {
				
				for(int j = 0; j<3; j++) {
					
					if( com[i] == user[j]) {
						if(i == j ) {
							s++;
						}
						else {
							b++;
						}
					}
				}
			}
			System.out.printf("Input Number: %d, Result : %dS-%dB\n",input, s,b);
			
			if(s == 3) {
				System.out.println("축하합니다 ! Game Over");
				break;
			}
		}
		
	
		
	}

}
